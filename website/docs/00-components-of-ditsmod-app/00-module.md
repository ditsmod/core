---
sidebar_position: 0
---

# Модулі

## Модуль Ditsmod

Оскільки Ditsmod спроектовано для хорошої модульності, одним з головних елементів його архітектури є модулі. Але чим хороша саме модульна архітектура? - Вона дозволяє ізолювати в одному модулі **декілька файлів коду**, що можуть мати різні ролі, але **спільну спеціалізацію**. Модуль можна порівняти з оркестром, в якому є різні інструменти, але усі вони створюють спільну музику. З іншого боку, потреба в ізоляції різних модулів виникає через те, що вони можуть мати різну спеціалізацію і через це - можуть заважати один-одному. Продовжуючи аналогію з людьми, якщо в одому кабінеті розмістити поліцію та музикантів, або брокерів і перекладачів, швидше за все, вони заважатимуть один-одному. Саме тому для модуля важлива **вузька спеціалізація**.

Разом з тим, модулі можуть мати ще й різні типи. Найчастіше використовуються два типи:

- **service** - сюди можна віднести модулі, що надають певні сервіси: модуль баз даних, модуль безпеки, модуль для запису логів, модуль для перекладу повідомлень різними мовами, і т.п.; такі модулі рідко закріпляються за певними URL.
- **routed** - сюди потрібно відносити модулі, що обслуговують певну частину URL: наприклад, один модуль може обробляти усі HTTP-запити за адресою `/api/users`, інший модуль - за адресою `/api/posts`.

Модулі можуть містити:
- контролери, що приймають HTTP-запити та відправляють HTTP-відповіді;
- сервіси, де описується бізнес логіка застосунку;
- інші класи, інтерфейси, хелпери, типи даних, що призначаються для роботи поточного модуля.

TypeScript клас стає модулем Ditsmod завдяки декоратору `featureModule`:

```ts
import { featureModule } from '@ditsmod/core';

@featureModule()
export class SomeModule {}
```

Файли модулів рекомендується називати із закінченням `*.module.ts`, а назви їхніх класів - із закінченням `*Module`.

У Ditsmod використовується декілька декораторів. Але чому саме декоратори? Тому що вони дозволяють у зручний спосіб закріпляти метадані за класами. Завдяки декораторам (у поєднанні з бібліотекою [reflect-metadata][1]), можна програмно розпізнавати:
- яку умовну роль закріплено за певним класом (роль модуля, контролера, сервіса і т.п.);
- чи має клас конструктор та які параметри він має;
- чи є у класа методи і які параметри вони мають;
- чи є інші властивості класу;
- інші метадані передані у декоратор.

:::tip Умовні ролі класу
Згадані тут ролі класу  - модуль, контролер, сервіс - є умовними (чи декларативними), оскільки вони мають значення виключно в контексті Ditsmod-застосунків, а сам TypeScript не має таких понять як "роль класу".
:::

Декоратори дозволяють декларативно описувати структуру застосунку, а тому можна легко проглядати що належить модулю, а також зв'язки одних модулів з іншими.

Загалом, в декоратор `featureModule` можна передавати об'єкт з такими властивостями:

```ts
import { featureModule } from '@ditsmod/core';

@featureModule({
  appends: [], // Прикріплені модулі (вони потрібні лише для успадкування префікса у поточного модуля)
  imports: [], // Імпорт модулів
  controllers: [], // Прив'язка контролерів до модуля
  providersPerApp: [], // Провайдери на рівні застосунку
  providersPerMod: [], //         ...на рівні модуля
  providersPerRou: [], //         ...на рівні роуту
  providersPerReq: [], //         ...на рівні запиту
  exports: [], // Експорт модулів та провайдерів з поточного модуля
  extensions: [], // Розширення
  extensionsMeta: {}, // Дані для роботи розширень
  resolvedCollisionsPerMod: [], // Вирішення колізій імпортованих класів на рівні модуля
  resolvedCollisionsPerRou: [], //                                    ...на рівні роута
  resolvedCollisionsPerReq: [], //                                    ...на рівні запиту
  id: '', // Може використовуватись для динамічного додавання чи видалення модулів
})
export class SomeModule {}
```

## Кореневий модуль Ditsmod

До кореневого модуля підв'язуються інші модулі, він є єдиним на увесь застосунок, а його клас рекомендовано називати `AppModule`. TypeScript клас стає кореневим модулем Ditsmod завдяки декоратору `rootModule`:

```ts
import { rootModule } from '@ditsmod/core';

@rootModule()
export class AppModule {}
```

Він може містити точно такі самі метадані як і некореневі модулі:

```ts
import * as http from 'http';
import { rootModule } from '@ditsmod/core';

@rootModule({
  appends: [],
  imports: [],
  controllers: [],
  providersPerApp: [],
  providersPerMod: [],
  providersPerRou: [],
  providersPerReq: [],
  exports: [],
  extensions: [],
  extensionsMeta: {},
  resolvedCollisionsPerApp: [],
  resolvedCollisionsPerMod: [],
  resolvedCollisionsPerRou: [],
  resolvedCollisionsPerReq: [],
})
export class AppModule {}
```


[1]: https://www.npmjs.com/package/reflect-metadata
