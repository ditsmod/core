---
sidebar_position: 4
---

# HTTP Інтерсептори

Інтерсептори дуже близькі по функціональності до контролерів, але вони не створюють роутів, вони прив'язуються до вже існуючих роутів. На одному роуті може працювати ціла група інтерсепторів, що запускаються один за одним. Інтерсептори - це аналог [middleware в ExpressJS][5], але інтерсептори можуть використовувати [DI][106]. Окрім цього, інтерсептори можуть працювати до та після роботи контролера.

Враховуючи що інтерсептори роблять таку ж роботу, яку можуть робити контролери, без інтерсепторів можна обійтись. Але в такому разі вам прийдеться значно частіше викликати різні сервіси в контролерах.

Як правило, інтерсептори використовуються для автоматизації стандартної обробки, такої як:

- парсинг тіла запиту чи заголовків;
- валідація запиту;
- збирання та логування різних метрик роботи застосунку;
- кешування;
- і т.д.

Інтерсептори можна централізовано підключати або відключати, не змінюючи при цьому код методів контролерів, до яких вони прив'язуються.

## Схема обробки HTTP-запиту

Обробка HTTP-запиту має наступний робочий потік:

1. Ditsmod створює інстанс [PreRouter][7] на рівні застосунку.
2. `PreRouter` за допомогою роутера шукає обробника запиту відповідно до URI.
3. Якщо обробника запиту не знайдено, `PreRouter` видає помилку зі статусом 501.
4. Якщо знайшовся обробник запиту, Ditsmod створює інстанс провайдера з токеном [HttpFrontend][2] на рівні запиту, ставить його першим у черзі інтерсепторів і автоматично викликає. By default, цей інтерсептор відповідає за виклик ґардів та встановлення значень для провайдерів з токенами `QUERY_PARAMS` та `PATH_PARAMS`.
5. Другий та наступні інтерсептори можуть і не запуститись, це залежать від того, чи запустить їх попередній у черзі інтерсептор.
6. Якщо усі інтерсептори відпрацювали, Ditsmod запускає [HttpBackend][3], інстанс якого створюється на рівні запиту. By default, `HttpBackend` запускає безпосередньо метод контролера, що відповідає за обробку поточного запиту.

Отже, приблизний порядок обробки запиту такий:

```text
    запит -> PreRouter -> HttpFrontend -> [інші інтерсептори] -> HttpBackend -> [контролер]
відповідь <- PreRouter <- HttpFrontend <- [інші інтерсептори] <- HttpBackend <- [контролер]
```

Оскільки інстанси `PreRouter`, `HttpFrontend` та `HttpBackend` створюються за допомогою DI, ви можете їх підміняти своєю версією відповідних класів. Наприклад, якщо ви хочете не просто відправити 501-ий статус у випадку відсутності потрібного роута, а хочете ще й додати певний текст чи змінити заголовки, ви можете підмінити [PreRouter][7] своїм класом.

Зверніть увагу, що кожен виклик інтерсептора повертає `Promise<any>`, і в кінцевому підсумку він приводить до метода контролера, прив'язаного до відповідного роута. Це означає, що в інтерсепторі ви можете слухати результат резолву проміса, що повертає метод контролера. Щоправда, на даний момент (Ditsmod v2.0.0), `HttpFrontend` та `HttpBackend` by default ігнорують усе, що повертає контролер чи інтерсептори, тому такий резолв проміса може бути корисним для інших цілей - для збору метрик, логування і т.п.

З іншого боку, через DI ви легко можете підмінити `HttpFrontend` та `HttpBackend` своїми власними інтерсепторами, щоб брати до уваги значення, що повертає метод контролера. Один із варіантів такої функціональності реалізовано у модулі [@ditsmod/return][104].

## Створення інтерсептора

Кожен інтерсептор повинен бути класом, що впроваджує інтерфейс [HttpInterceptor][1], та має анотацію з декоратором `injectable`:

```ts
import { injectable, InterceptorContext, HttpHandler, HttpInterceptor } from '@ditsmod/core';

@injectable()
export class MyHttpInterceptor implements HttpInterceptor {
  intercept(next: HttpHandler, ctx: InterceptorContext) {
    return next.handle(); // Here returns Promise<any>;
  }
}
```

Як бачите, метод `intercept()` має два параметри: у перший передається інстанс обробника, що викликає наступний інтерсептор, а у другий - `InterceptorContext` (нативні об'єкти запиту та відповіді від Node.js). Якщо для своєї роботи інтерсептор потребує додаткових даних, їх можна отримати в конструкторі через DI, як і в будь-якому сервісі.

## Передача інтерсептора в інжектор

Будь-який інтерсептор передається в інжектор на рівні запиту за допомогою [мульти-провайдерів][107] з токеном `HTTP_INTERCEPTORS`:

```ts
import { HTTP_INTERCEPTORS, featureModule } from '@ditsmod/core';

import { MyHttpInterceptor } from './my-http-interceptor.js';

@featureModule({
  // ...
  providersPerReq: [{ token: HTTP_INTERCEPTORS, useClass: MyHttpInterceptor, multi: true }],
})
export class SomeModule {}
```

В даному разі інтерсептори передаються в метадані модуля. Так само вони можуть передаватись у метадані контролера. Тобто інтерсептори можуть працювати або для усіх контролерів у модулі без виключень, або тільки для конкретного контролера. Якщо інтерсептори потрібно додати лише до окремих роутів у межах контролерів, це ви можете зробити за допомогою [розширень][108] (таким чином додаються [інтерсептори для парсингу тіла запиту][9]).

[1]: https://github.com/ditsmod/ditsmod/blob/core-2.38.1/packages/core/src/types/http-interceptor.ts#L20-L22
[2]: https://github.com/ditsmod/ditsmod/blob/core-2.38.1/packages/core/src/services/default-http-frontend.ts
[3]: https://github.com/ditsmod/ditsmod/blob/core-2.38.1/packages/core/src/services/default-http-backend.ts
[5]: https://expressjs.com/en/guide/writing-middleware.html
[7]: https://github.com/ditsmod/ditsmod/blob/core-2.38.1/packages/core/src/services/pre-router.ts
[8]: https://github.com/ditsmod/ditsmod/blob/core-2.38.1/packages/core/src/types/route-data.ts
[9]: https://github.com/ditsmod/ditsmod/blob/core-2.38.1/packages/body-parser/src/body-parser.extension.ts#L36

[104]: /native-modules/return
[106]: /components-of-ditsmod-app/dependency-injection
[107]: /components-of-ditsmod-app/dependency-injection#мульти-провайдери
[108]: /components-of-ditsmod-app/extensions
