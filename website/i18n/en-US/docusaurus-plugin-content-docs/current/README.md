# Що таке Ditsmod

Ditsmod є Node.js веб-фреймворком, його назва складається із **DI** + **TS** + **Mod**, щоб підкреслити важливі складові: він має **D**ependency **I**njection, написаний на **T**ype**S**cript, та спроектований для хорошої **Mod**ularity (тобто модульності).

Головні особливості Ditsmod:

- Зручний механізм [указання та вирішення залежностей][8] між різними класами застосунку: ви в конструкторі указуєте інстанси яких класів вам потрібні, а DI бере на себе непросту задачу "як їх отримати".
- Можливість легко підмінювати by default класи в ядрі Ditsmod своїми власними класами. Наприклад, швидше за все, ви захочете підмінити клас логера на ваш власний клас, оскільки by default логер записує усе лише в консоль.
- Можливість легко підмінювати класи вашого застосунку тестовими класами (mocks, stubs), не змінюючи при цьому код вашого застосунку. Це дуже суттєво спрощує тестування.
- Ditsmod спроектований, щоб забезпечувати хорошу модульність всього застосунку, а отже і хорошу масштабованість. Його DI підтримує ієрархію, а це означає, що ви можете оголошувати [одинаків][12]: або на рівні усього застосунку, або на рівні конкретного модуля, або на рівні конкретного маршруту, або на рівні HTTP-запиту.

Ті, хто знайомий з [Angular][9], помітить, що деякі концепції архітектури цього фреймворка дуже схожі на Angular концепції. Це справді так, більше того - сам [DI][11] фактично витягнутий з Angular v4.4.7. (з мінімальними допрацюваннями) та інтегрований в Ditsmod.

## Зміст

- [Встановлення](#встановлення)
- [Запуск](#запуск)
- [Вхідний файл для Node.js][123]
- [Модуль Ditsmod][150]
- [Кореневий модуль][102]
- [Контролер][103]
- [Оголошення контролера][111]
- [Сервіс][104]
- [Dependency Injection][105]
  - [Оголошення рівня провайдерів та підміна провайдерів][100]
- [Експорт провайдерів у звичайному модулі][107]
- [Експорт провайдерів у кореневому модулі][108]
- [Імпорт модуля][109]
- [Реекспорт модуля][110]
- [Префікси маршрутів][112]
- [Guards][113]
  - [Параметри для guards][114]
- [Автоматичний парсинг тіла HTTP-запиту][115]
- [Підміна by default класів Ditsmod][116]
- [Різниця між областю видимості провайдерів та їх рівнями оголошення][117]
- [Інжектори DI][118]
  - [Поточний інжектор][142]
  - [Токени DI][119]
  - [InjectionToken][120]
- [Колізії провайдерів][121]
- [Домовленості по стилю коду][122]
- [API reference][106]

## Встановлення

Мінімальний базовий набір для роботи застосунку має репозиторій [ditsmod-seed][2]. Клонуйте його та встановіть залежності:

```bash
git clone git@github.com:ditsmod/seed.git my-app
cd my-app
yarn
```

## Запуск

```bash
yarn start
```

Такий запуск можна використовувати для розробки застосунку, оскільки після кожного збереження вашого коду, ви зможете зразу бачити ці зміни.

Перевірити роботу сервера можна за допомогою `curl`:

```bash
curl -isS localhost:8080
```

Компіляція застосунку відбувається за допомогою команди:

```bash
yarn build
```

Окрім цього, можете проглянути більше прикладів у теці [examples][4].

## Вхідний файл для Node.js

Після [встановлення Ditsmod seed](#встановлення), перше, що необхідно знати: весь код застосунку знаходиться у теці `src`, він компілюється за допомогою TypeScript-утиліти `tsc`, після компіляції попадає у теку `dist`, і далі вже у вигляді JavaScript-коду його можна виконувати у Node.js.

Давайте розглянемо файл `src/main.ts`:

```ts
import 'reflect-metadata';
import { Application } from '@ditsmod/core';

import { AppModule } from './app/app.module';

new Application()
  .bootstrap(AppModule)
  .then(({ server, logger }) => {
    server.on('error', (err) => logger.error(err));
  })
  .catch(({ err, logger }) => {
    logger.fatal(err);
    throw err;
  });
```

Після компіляції, він перетворюється на `dist/main.js` та стає вхідною точкою для запуску застосунку, і саме тому ви будете його вказувати у якості аргументу для Node.js:

```bash
node dist/main.js
```

Слід звернути увагу на `import 'reflect-metadata'` у першому рядку файла. Цей модуль необхідний для роботи Ditsmod, але його достатньо указувати єдиний раз у вхідному файлі для Node.js.

Бажано запам'ятати дане правило на майбутнє, і застосовувати його також для написання тестів, оскільки в такому разі вхідним файлом вже буде файл тесту, а не `dist/main.js`. Наприклад, якщо ви будете використовувати [jest][10] у якості фреймворку для тестів, а файл `path/to/test-file.js` міститиме скомпільований тест, то щоб запустити його ось так:

```bash
jest path/to/test-file.js
```

у даному файлі повинен бути імпорт `reflect-metadata`.

Проглядаючи далі файл `src/main.ts`, ми бачимо, що створюється інстанс класу `Application`, а у якості аргументу для методу `bootstrap()` передається `AppModule`. Тут `AppModule` є кореневим модулем, до якого вже підв'язуються інші модулі застосунку.

## Модуль Ditsmod

Коротко кажучи, модуль об'єднує у собі набір класів, що мають вузьку спеціалізацію. Добре оформлений модуль не повинен бути "універсальним комбайном".

Наприклад, модуль системи безпеки має вузьку спеціалізацію - безпека доступу та безпека управління застосунком. Тут не повинні оголошуватись класи, наприклад, що перекладають повідомлення різними мовами, що відправляють пошту, що пишуть логи і т.п.

Коли конкретний модуль прив'язаний до певного URL - це теж хороша практика, і це теж можна вважати "вузькою спеціалізацією". Наприклад, один модуль може обробляти усі HTTP-запити за адресою `/api/users`, інший модуль - за адресою `/api/posts`.

TypeScript клас стає модулем Ditsmod завдяки декоратору `Module`:

```ts
import { Module } from '@ditsmod/core';

@Module()
export class SomeModule {}
```

Загалом, в декоратор `Module` можна передавати об'єкт із такими властивостями:

```ts
import { Module } from '@ditsmod/core';

@Module({
  imports: [], // Імпорт інших модулів
  controllers: [],
  providersPerApp: [], // Провайдери на рівні застосунку
  providersPerMod: [], // Провайдери на рівні модуля
  providersPerRou: [], // Провайдери на рівні роуту
  providersPerReq: [], // Провайдери на рівні запиту
  exports: [], // Експорт модулів та провайдерів із поточного модуля
  extensions: [] // Розширення
})
export class SomeModule {}
```

## Кореневий модуль Ditsmod

До кореневого модуля підв'язуються інші модулі, він є єдиним на увесь застосунок, а його клас рекомендовано називати `AppModule`. TypeScript клас стає кореневим модулем Ditsmod завдяки декоратору `RootModule`:

```ts
import { RootModule } from '@ditsmod/core';

@RootModule()
export class AppModule {}
```

Він може містити інформацію як для HTTP-сервера так і для самого модуля. Загалом, в декоратор `RootModule` можна передавати об'єкт із такими властивостями:

```ts
import * as http from 'http';
import { RootModule } from '@ditsmod/core';

@RootModule({
  // Дані для HTTP-сервера
  httpModule: http,
  listenOptions: { host: 'localhost', port: 8080 },
  serverName: 'Node.js',
  serverOptions: {},

  // Дані для модуля, плюс - префікс, що додаватиметься до усіх маршрутів
  prefixPerApp: 'api',
  imports: [],
  controllers: [],
  providersPerApp: [],
  providersPerMod: [],
  providersPerRou: [],
  providersPerReq: [],
  exports: [],
  extensions: []
})
export class SomeModule {}
```

Для повноцінної роботи, щоб можна було обробляти певні URL маршрути, потрібні контролери.

## Контролер

Контролери призначаються для прийому HTTP-запитів та відправки HTTP-відповідей. TypeScript клас стає контролером Ditsmod завдяки декоратору `Controller`:

```ts
import { Controller } from '@ditsmod/core';

@Controller()
export class SomeController {}
```

Запити прив'язуються до методів контролерів через систему маршрутизації, з використанням декоратора `Route`. В наступному прикладі створено два маршрути, що приймають `GET` запити за адресами `/hello` та `/throw-error`:

```ts
import { Controller, Response, Route } from '@ditsmod/core';

@Controller()
export class SomeController {
  constructor(private res: Response) {}

  @Route('GET', 'hello')
  tellHello() {
    this.res.send('Hello World!');
  }

  @Route('GET', 'throw-error')
  thrwoError() {
    throw new Error('Here some error occurred');
  }
}
```

Що ми тут бачимо:

1. В конструкторі класу за допомогою модифікатора доступу `private` оголошується властивість класу `res` із типом даних `Response`. Таким чином ми просимо Ditsmod щоб він створив інстанс класу `Response` і передав його у змінну `res`.
1. Маршрути створюються за допомогою декоратора `Route`, що ставиться перед методом класу.
1. Відповіді на HTTP-запити відправляються через `this.res.send()` (хоча `this.res` ще має `sendJson()` та `sendText()`).
1. Об'єкти помилок можна кидати прямо в методі класу звичайним для JavaScript способом, тобто за допомогою ключового слова `throw`.

**Уточнення**: модифікатор доступу в конструкторі може бути будь-яким (`private`, `protected` або `public`), але взагалі без модифікатора - `res` вже буде простим параметром з видимістю лише в конструкторі.

**Підказка**: якщо у конструкторі ви прописуєте клас `Request` чи `Response`, не забувайте імпортувати їх із `@ditsmod/core`! Якщо ви цього не зробите, ваш застосунок перестане працювати, хоча IDE може і не підказати, що у вас неімпортовані дані класи. Справа в тому, що у TypeScript глобально оголошено інтерфейси з точно такими іменами - `Request` та `Response`. Через це ваша IDE може лише сказати, що у цих інтерфейсів немає певних властивостей, що повинні бути у класів, імпортованих з `@ditsmod/core`.

Щоб використовувати `pathParams`, `queryParams` чи `body`, у конструкторі контролера необхідно запитати інстанс класу `Request`:

```ts
import { Controller, Request, Response, Route } from '@ditsmod/core';

@Controller()
export class SomeController {
  constructor(private req: Request, private res: Response) {}

  @Route('GET', 'hello/:userName')
  tellHello() {
    const { pathParams } = this.req;
    this.res.send(`Hello, ${pathParams.userName}`);
  }

  @Route('POST', 'some-url')
  tellHello() {
    const { body, queryParams } = this.req;
    this.res.sendJson(body, queryParams);
  }
}
```

Щойно в конструкторі ми отримали інстанси класів `Request` та `Response`, вони представляють собою так звані сервіси.

## Сервіс

TypeScript клас стає сервісом Ditsmod завдяки декоратору `Injectable`:

```ts
import { Injectable } from '@ts-stack/di';

@Injectable()
export class SomeService {}
```

Зверніть увагу, що цей декоратор імпортується із `@ts-stack/di`, а не із `@ditsmod/core`. Приклади сервісів в затосунках Ditsmod:

- сервіс надання конфігурації;
- сервіс роботи з базами даних, з поштою і т.п.;
- сервіс парсингу тіла HTTP-запиту;
- сервіс перевірки прав доступу;
- і т.д.

Часто одні сервіси залежать від інших сервісів, і щоб отримати інстанс певного сервіса, необхідно указувати їхні класи в конструкторі:

```ts
import { Injectable } from '@ts-stack/di';

import { FirstService } from './first.service';

@Injectable()
export class SecondService {
  constructor(private firstService: FirstService) {}

  methodOne() {
    this.firstService.doSomeThing();
  }
}
```

Як бачите, правила отримання інстансу класу в сервісі такі ж самі, як і в контролері. Тобто, ми в конструкторі за допомогою модифікатора доступу `private` оголошуємо властивість класу `firstService` із типом даних `FirstService`. Інстанси в конструкторі створює [DI][8].

## Dependency Injection

На етапі ініціалізації застосунку, DI збирає метадані модулів, контролерів та сервісів, після чого аналізує **залежність** кожного із класів від інших класів та готує відповідні набори щоб **вирішити цю залежність**.

Наприклад, якщо модуль безпеки, потребує модуль баз даних та модуль логів, DI готує набір класів, зібраних із цих двох модулів.

Отже виходить, що якщо певний клас залежить від іншого класу, він його не імпортує напряму з конкретного файла, а бере через посередника - через систему DI. Така схема роботи дозволяє підміняти класи через DI.

На практиці це означає, наприклад, що ви можете підміняти by default логер своїм власним логером. Причому, зверніть увагу, що ви не просто можете використовувати інший логер, а ви можете робити саме **підміну** вже прописаного в коді логера. Ви можете сказати: "DI, використовуй мій логер у будь-якому місці застосунку і навіть у ядрі Ditsmod".

Це ж саме стосується будь-яких класів, від яких залежать інші класи - їх усіх можна підміняти через DI. Тобто окрім логера, ви можете підміняти: роутер, парсер тіла запиту, обробник помилок, різні by default конфігурації і навіть класи запитів та відповідей.

Для розробника це відкриває широкі можливості як для зміни так і для розширення застосунку Ditsmod.

І щоб надавати в конструкторі класу те, що ви запитуєте, [DI][8] повинен бути проінструктований звідки це брати. Але це може здатись дивним. Чому? - Давайте глянемо на приклад:

```ts
import { Injectable } from '@ts-stack/di';

import { FirstService } from './first.service';

@Injectable()
export class SecondService {
  constructor(private firstService: FirstService) {}

  methodOne() {
    this.firstService.doSomeThing();
  }
}
```

Тут DI повинен надати інстанс класу `FirstService` і, на перший погляд, ви чітко прописуєте з якого файлу імпортувати даний клас, але цього не достатньо, бо DI запам'ятовує `FirstService` лише у якості ключа для пошуку. Це зроблено для того, щоб потім ви могли сказати: "DI, коли бачиш цей ключ, роби інстанс такого-то класу, і підставляй його сюди".

[Пізніше][100] ви дізнаєтесь, що не змінюючи коду в даному прикладі, ви можете підмінити клас `FirstService`, наприклад, тестовим класом. Коли ви підмінюєте один клас іншим класом ви, можна сказати, надаєте інший **провайдер** для створення інстансу класу.

Точно так само, не змінюючи коду прикладу, ви ще можете змінити **рівень**, на якому оголошено провайдер для `FirstService`, щоб його інстанс створювався:

- або один єдиний раз при старті застосунку;
- або кожен раз, коли його імпортують в черговий модуль;
- або кожен раз, коли створюється конкретний маршрут;
- або за кожним HTTP-запитом.

Оскільки, не змінюючи коду даного прикладу, ви можете отримувати різні результати у властивості `firstService`, виходить, що не достатньо просто указати джерело імпорту для певного сервіса. Для однозначності, як мінімум, необхідно додатково оголосити **рівень** провайдера `FirstService`.

_Підказка_: Щоб не плутати поняття **провайдер** із поняттям **сервіс**, можна згадати за провайдерів інтернету. Таких провайдерів може бути багато, але конкретно вам - сервіс надає один-два провайдери. Аналогічно в Ditsmod - сервіс ви отримуєте в конкретному контролері, а провайдерів для цього сервісу може бути багато.

### Оголошення рівня провайдерів та підміна провайдерів

Оголошення рівня провайдерів означає, що на цьому рівні інстанси зазначених класів провайдерів будуть [одинаками][12]. Таке оголошення робиться або у метаданих модуля, або у метаданих контролера.

Наприклад, в контролері можна оголосити провайдерів на рівні HTTP-запиту:

```ts
import { Controller } from '@ditsmod/core';

import { SomeService } from './some.service';

@Controller({ providersPerReq: [SomeService] })
export class SomeController {
  constructor(private someService: SomeService) {}
}
```

Як бачимо, в метаданих декоратора `Controller` є об'єкт із властивістю `providersPerReq`, куди передається масив провайдерів, яких потребує даний контролер у конструкторі.

А якщо ми захочемо зробити підміну провайдера, то ми запишемо це так:

```ts
import { Controller } from '@ditsmod/core';

import { FirstService } from './first.service';
import { SecondService } from './second.service';

@Controller({ providersPerReq: [{ provide: FirstService, useClass: SecondService }] })
export class SomeController {
  constructor(private firstService: FirstService) {}
}
```

Тобто замість передачі класу `FirstService` у масив `providersPerReq`, ми передаємо об'єкт `{ provide: FirstService, useClass: SecondService }`. Таким чином ми інструктуємо DI щоб для конструктора замість інстансу класу `FirstService`, передавати інстанс класу `SecondService`.

В модулі також можна оголошувати провайдери на рівні HTTP-запиту, але вони матимуть нижчій пріоритет, ніж оголошення через контролер:

```ts
import { Module } from '@ditsmod/core';

import { SomeService } from './some.service';

@Module({
  providersPerApp: [],
  providersPerMod: [],
  providersPerRou: [],
  providersPerReq: [SomeService],
})
export class SomeModule {}
```

Як бачите, в метаданих модуля оголошувати провайдери вже можна на **чотирьох рівнях**.

### Пріоритетність провайдерів

Один і той самий провайдер, на одному й тому самому рівні можна додавати багато разів, але DI вибире той із них, що додано останнім (виключення з цього правила є, але це стосується лише мульти-провайдерів, про які буде згадано пізніше). Окрім цього, один і той самий провайдер можна оголошувати одночасно на чотирьох рівнях, але провайдери в масиві `providersPerReq` матимуть найвищий пріоритет, в масиві `providersPerRou` - нижчій, в масиві `providersPerMod` - ще нижчій, а у `providersPerApp` - найнижчий пріоритет.

Це можна використовувати, наприклад, так:

1. спочатку у кореневому модулі оголосіть певний провайдер конфігурації **на рівні застосунку**
2. при потребі змінити дану конфігурацію лише для окремого модуля, ви оголошуєте цей же провайдер конфігурації, але вже **на рівні модуля**, і робите його підміну.

Також, якщо ви імпортуєте певний провайдер із зовнішнього модуля, і у вас у поточному модулі є такий же провайдер, то локальний провайдер матиме вищій пріоритет, при умові, що вони оголошені на однаковому рівні. Аналогічне правило діє і для контролера - провайдер, оголошений у контролері, матиме вищій пріоритет, ніж провайдер, із таким же токеном, оголошений в модулі.

## Експорт провайдерів зі звичайного модуля

Експортуючи провайдери з певного модуля, ви тим самим декларуєте, що вони є доступними для використання в інших модулях, які імпортуватимуть цей модуль:

```ts
import { Module } from '@ditsmod/core';

import { SomeService } from './some.service';

@Module({
  providersPerMod: [SomeService],
  exports: [SomeService],
})
export class SomeModule {}
```

Зверніть увагу, що відбувається не лише додавання `SomeService` в масив `exports`, одночасно цей провайдер оголошується на рівні `providersPerMod`. При експорті, _оголошення_ провайдера на певному рівні є обов'язковим.

Експортувати провайдери можна лише ті, що оголошені:

1. або на рівні модуля (тобто в масиві `providersPerMod`)
2. або на рівні роута (тобто в масиві `providersPerRou`).
3. або на рівні HTTP-запиту (тобто в масиві `providersPerReq`).

Експортувати провайдери, що оголошені на рівні застосунку (тобто в масиві `providersPerApp`) не має сенсу, оскільки _оголошення_ їх на рівні застосунку вже має на увазі _експорт_ їх на цьому рівні.

Також не має сенсу експортувати контролери, оскільки експорт стосується виключно провайдерів.

## Експорт провайдерів із кореневого модуля

Експорт провайдерів із кореневого модуля означає, що ці провайдери стають доступними для будь-якого сервіса чи контролера у всьому застосунку, причому їхній рівень оголошення зберігається:

```ts
import { RootModule } from '@ditsmod/core';

import { SomeService } from './some.service';

@RootModule({
  providersPerMod: [SomeService],
  exports: [SomeService],
})
export class AppModule {}
```

## Імпорт модуля

Імпортувати окремий провайдер в модуль Ditsmod не можна, але можна імпортувати цілий модуль із усіма провайдерами, що експортуються в ньому:

```ts
import { Module } from '@ditsmod/core';

import { FirstModule } from './first.module';
import { SecondModule } from './second.module';

@Module({
  imports: [
    FirstModule,
    { prefix: 'some-prefix', module: SecondModule }
  ]
})
export class ThridModule {}
```

Якщо у `FirstModule` експортується, наприклад, `SomeService`, то тепер цей сервіс можна використовувати у `ThridModule` у будь-якому його сервісі чи контролері.

Зверніть увагу, що при імпорті рівень оголошення провайдера залишається таким самим, яким він був при експорті. Наприклад, якщо `SomeService` було оголошено на рівні модуля, то і при імпорті залишиться цей же рівень.

Як бачите, масив `imports` приймає окрім класів модулів, ще й об'єкт `{ prefix: 'some-prefix', module: SecondModule }`. Вказаний префікс `some-prefix` буде використовуватись для маршрутизації, якщо у `SecondModule` оголошено контролери.

Разом із тим, у поточному модулі покищо не забороняється повторно оголошувати рівень провайдера, що написаний і вже оголошений у зовнішньому модулі. Але це рекомендується робити, тільки якщо ви вирішуєте [колізію експортованих провайдерів][121]. Якщо вам потрібен провайдер із зовнішнього модуля, імпортуйте цей зовнішній модуль повністю.

І якщо ви хочете використовувати провайдер, що не експортується із зовнішнього модуля, то це також не рекомендується робити, оскільки ви будете опиратись на непублічний API, що може змінитись у будь-який момент без попередження.

## Реекспорт модуля

Окрім імпорту певного модуля, цей же модуль можна одночасно й експортувати:

```ts
import { Module } from '@ditsmod/core';

import { FirstModule } from './first.module';

@Module({
  imports: [FirstModule],
  exports: [FirstModule],
})
export class SecondModule {}
```

Який у цьому сенс? - Тепер, якщо ви зробите імпорт `SecondModule` у якийсь інший модуль, ви фактично матимете імпортованим ще й `FirstModule`.

## Оголошення контролера

Оголошувати контролер можна у будь-якому модулі, у масиві `controllers`:

```ts
import { Module } from '@ditsmod/core';

import { SomeController } from './first.controller';

@Module({
  controllers: [SomeController]
})
export class SomeModule {}
```

## Префікси маршрутів

Якщо звичайний модуль імпортувати з префіксом, даний префікс буде додаватись до усіх маршрутів (роутів), в межах цього модуля:

```ts
import { Module } from '@ditsmod/core';

import { FirstModule } from './first.module';
import { SecondModule } from './second.module';

@Module({
  imports: [
    { prefix: 'some-prefix', module: FirstModule }
    { prefix: 'other-prefix/:pathParam', module: SecondModule }
  ]
})
export class ThridModule {}
```

Тут під записом `:pathParam` мається на увазі не просто текст, а саме параметр - змінна частина в URL перед query параметрами.

Якщо ж в кореневому модулі указати `prefixPerApp`, цей префікс буде додаватись до усіх маршрутів в усьому застосунку:

```ts
import { RootModule } from '@ditsmod/core';

import { SomeModule } from './some.module';

@RootModule({
  prefixPerApp: 'api',
  imports: [SomeModule]
})
export class AppModule {}
```

## Guards

Якщо вам необхідно щоб до певних маршрутів мали доступ, наприклад, лише авторизовані користувачі, ви можете у третьому параметрі декоратора `Route`, в масиві указати `AuthGuard`:

```ts
import { Controller, Response, Route } from '@ditsmod/core';

import { AuthGuard } from './auth.guard';

@Controller()
export class SomeController {
  constructor(private res: Response) {}

  @Route('GET', 'some-url', [AuthGuard])
  tellHello() {
    this.res.send('Hello admin!');
  }
}
```

Будь-який guard повинен впроваджувати інтерфейс `CanActivate`:

```ts
interface CanActivate {
  canActivate(params?: any[]): boolean | number | Promise<boolean | number>;
}
```

Наприклад, це можна зробити так:

```ts
import { Injectable } from '@ts-stack/di';
import { CanActivate } from '@ditsmod/core';

import { AuthService } from './auth.service';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService) {}

  async canActivate() {
    return Boolean(await this.authService.updateAndGetSession());
  }
}
```

Якщо `canActivate()` повертає:

- `true` чи `Promise<true>`, значить Ditsmod буде обробляти відповідний маршрут із цим гардом;
- `false` чи `Promise<false>`, значить відповідь на запит міститиме 401 статус і обробки маршруту з боку контролера не буде;
- `number` чи `Promise<number>` Ditsmod інтерпретує це як номер статусу (403, 401 і т.п.), який треба повернути у відповіді на HTTP-запит.

### Параметри для guards

У методі `canActivate()` гард має один параметр. Аргументи для цього параметру можна передавати у декораторі `Route` у масиві, де на першому місці йде певний гард.

Давайте розглянемо такий приклад:

```ts
import { Controller, Response, Route } from '@ditsmod/core';

import { PermissionsGuard } from './permissions.guard';
import { Permission } from './permission';

@Controller()
export class SomeController {
  constructor(private res: Response) {}

  @Route('GET', 'some-url', [[PermissionsGuard, Permission.canActivateAdministration]])
  tellHello() {
    this.res.send('Hello admin!');
  }
}
```

Як бачите, на місці третього параметра у `Route` передається масив в масиві, де на першому місці указано `PermissionsGuard`, а далі йдуть аргументи для нього. В такому разі `PermissionsGuard` отримає ці аргументи у своєму методі `canActivate()`:

```ts
import { Injectable } from '@ts-stack/di';
import { CanActivate, Status } from '@ditsmod/core';

import { AuthService } from './auth.service';
import { Permission } from './permission';

@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private authService: AuthService) {}

  async canActivate(params?: Permission[]) {
    if (await this.authService.hasPermissions(params)) {
      return true;
    } else {
      return Status.FORBIDDEN;
    }
  }
}
```

## Автоматичний парсинг тіла HTTP-запиту

Якщо ви експортували `BodyParserModule` із кореневого модуля, Ditsmod на етапі ініціалізації застосунку проглядає який HTTP-метод указується в декораторі `Route` для певного маршрута, щоб визначити чи потрібно парсити тіло запиту в майбутньому. Перелік HTTP-методів, для яких потрібно парсити тіло запиту, указано в класі `BodyParserConfig` у властивості `acceptMethods`:

```ts
export class BodyParserConfig {
  acceptMethods: HttpMethod[] = ['POST', 'PUT', 'PATCH'];
  acceptHeaders: string[] = ['application/json', 'application/x-www-form-urlencoded', 'text/plain', 'text/html'];
  maxBodySize: number = 1024 * 1024 * 5; // 5 MB
  multipartOpts: MultipartBodyParserOptions = {};
}
```

Оскільки цей клас Ditsmod отримує від DI, ви можете змінити дані налаштування підмінивши `BodyParserConfig` вашим власним класом:

```ts
import { Module, BodyParserConfig } from '@ditsmod/core';

import { MyBodyParserConfig } from './my-body-parser-config';

@Module({
  providersPerMod: [{ provide: BodyParserConfig, useClass: MyBodyParserConfig }]
})
export class SomeModule {}
```

Враховуючи те, що `BodyParserConfig` у ядрі Ditsmod оголошено на рівні застосунку, ви можете [понизити цей рівень][127] до рівня модуля, чи запиту. Якраз це і відбувається в даному прикладі, бо тут `BodyParserConfig` оголошується вже на рівні модуля. Це означає, що внесені вами зміни будуть діяти в межах `SomeModule`.

## Підміна by default провайдерів Ditsmod

У ядрі Ditsmod оголошуються наступні провайдери:

### на рівні застосунку

- Logger
- LoggerConfig
- BodyParserConfig
- Router
- PreRequest
- ExtensionsManager
- PreRouter
- Counter
- ModuleManager

### на рівні HTTP-запиту

- Request
- Response
- BodyParser
- ControllerErrorHandler

Оскільки усі by default провайдери додаються до DI першими, кожного із них ви можете підмінити своїми провайдерами.

Мабуть перше, що ви захочете підмінити - це провайдер логера, оскільки початково `Logger` записує усе лише в консоль, і використовується як токен для DI, а також як інтерфейс.

Що означає "використовується як інтерфейс"? - Це означає, що якщо ви хочете підміняти `Logger` своїм провайдером, ваш провайдер повинен мати такі ж методи, і таку ж сигнатуру цих методів як вона є у `Logger`.

Коли ваш провайдер впровадить інтерфейс `Logger`, вам залишиться зробити його підміну за допомогою DI:

```ts
import { RootModule, Logger } from '@ditsmod/core';

import { MyLogger } from './my-logger';

@RootModule({
  providersPerApp: [{ provide: Logger, useClass: MyLogger }]
})
export class SomeModule {}
```

Щоб підмінити будь-який by default провайдер Ditsmod вашим власним провайдером, алгоритм ваших дій такий же, як це було показано у попередньому прикладі:

1. вивчаєте [API провайдерів][106], які ви хочете підмінити;
2. впроваджуєте такий самий API у своїх провайдерів;
3. робите підміну by default провайдера вашим провайдером.

### Експорт підмінених by default провайдерів

Хоча сама підміна by default провайдерів для конкретного модуля є простою і зромілою процедурою, але коли ви експортуватимете ці провайдери для інших модулів, тут ви маєте схопити приблизно таку помилку:

> Error: Exporting providers in AppModule was failed: Collision was found for: BodyParser. You should manually add this provider to AppModule.

Більш докладно про цю помилку можете прочитати у розділі [Колізії провайдерів][121].

## Різниця між областю видимості провайдерів та їх рівнями оголошення

Не варто плутати чотири рівня оголошення провайдерів із областю їх видимості. Коли ви передаєте провайдер у один із масивів: `providersPerApp`, `providersPerMod`, `providersPerRou` чи `providersPerReq` - тим самим ви декларуєте на якому рівні буде створюватись [одинак][12] даного провайдера. Але це не теж саме, що область видимості провайдерів.

Наприклад, якщо у `SomeModule` ви оголосили `ConfigService` на рівні `providersPerMod`, це означає, що одинак даного сервісу буде створений на рівні даного модуля і стане доступним лише в межах цього модуля. Тобто будь-який інший модуль покищо не зможе побачити `ConfigService`.

Разом із тим, щоб збільшити область видимості `ConfigService` ви повинні експортувати його із `SomeModule`, після чого усі модулі, що імпортують `SomeModule`, теж матимуть свій окремий одинак `ConfigService` на рівні модуля.

Як бачите, область видимості провайдерів розширюється за допомогою [експорту цих провайдерів][107] з подальшим імпортом модулів, де вони оголошені. Хоча, якщо провайдери оголошені у кореневому модулі, і вони потрібні вам в іншому модулі, імпортувати кореневий модуль не потрібно. Достатньо в кореневому модулі зробити експорт потрібних провайдерів, після чого їх область видимості збільшиться на увесь застосунок.

Але якщо область видимості не розширювати, вона буде обмежуватись лише ієрархією інжекторів DI (див. наступний розділ).

## Інжектори DI

Інжектори є складовою частиною DI, і хоча раніше вони майже не згадувались в документації, ви з їхньою роботою вже трохи знайомі - саме інжектори видають вам те, що ви запитуєте у конструкторах класів. Інжектори - це інстанси класів, що мають масиви провайдерів та методи для пошуку цих провайдерів. Коли ви передаєте провайдери в масиви `providersPerApp`, `providersPerMod`, `providersPerRou` та `providersPerReq` ви фактично передаєте ці дані в чотири різні інжектори, пов'язані між собою ієрархічним зв'язком. Цей зв'язок утримує дочірній інжектор, оскільки має посилання на батьківський інжектор. У той же час, батьківський інжектор нічого не знає про свої дочірні інжектори.

_Уточнення_: згадані чотири інжектори - це не загальна кількість інжекторів в застосунку, це кількість інжекторів в ієрархії. Тобто, окремо взятий контролер працює саме із цими чотирма інжекторами, але оскільки контролерів може бути багато, то і інжекторів відповідно може бути більше.

Отже, згадані чотири інжектори мають таку ієрархію:

1. Самий вищий в ієрархії - інжектор на рівні застосунку, він бачить лише ті провайдери, що ви передаєте у масив `providersPerApp` будь-де в застосунку. Він є єдиним на весь застосунок, від нього відгалуджуються дочірні інжектори на рівні модуля.
2. Інжектор на рівні модуля бачить усі провайдери в масиві `providersPerMod` для конкретного модуля, а також в масиві `providersPerApp` будь-де в застосунку. Загальна кількість таких інжекторів дорівнює кількості модулів у застосунку. Від цього інжектора відгалуджуються дочірні інжектори на рівні роуту (маршруту).
3. Інжектор на рівні роуту бачить усі провайдери в масиві `providersPerRou` та `providersPerMod` конкретного модуля, а також у `providersPerApp` будь-де в застосунку. Загальна кількість цих інжекторів дорівнює кількості визначених роутів в контролерах усього застосунку. Від цього інжектора відгалуджуються дочірні інжектори на рівні HTTP-запиту.
4. Інжектор на рівні HTTP-запиту бачить усі провайдери в масиві `providersPerReq`, `providersPerRou` та `providersPerMod` конкретного модуля, а також у `providersPerApp` будь-де в застосунку. Кількість цих інжекторів дорівнює кількості одночасних HTTP-запитів, що обробляються у заданий проміжок часу.

Кожен інжектор для створення [одинаків][12] використовує лише ті провайдери, що оголошені на його рівні. Наприклад, інжектор, на рівні запиту, створює одинаків лише з переліку провайдерів, оголошених в масиві `providersPerReq`. І хоча він також бачить провайдерів батьківських інжекторів, але він може використовувати лише вже готові батьківські інстанси провайдерів, а не створювати їх. Таким чином, в конструкторі контролера можуть бути одинаки з будь-якого рівня.

Кожен інжектор спочатку проглядає те, що у нього запитують, на своєму рівні. Якщо він це не знаходить, він може звернутись до батьківського інжектора, що знаходиться на рівень вище, якщо такий існує. А батьківський інжектор, у свою чергу, може піднятись ще вище, аж поки не знайде потрібне, в противному разі DI кидає помилку.

Щоб зрозуміти, що це означає на практиці, давайте розглянемо конкретний приклад.

Припустимо ви створили `ErrorHandlerService` і думаєте: "Де б його оголосити? - Раз цей сервіс може знадобитись у будь-якій точці застосунку, значить треба оголосити його саме на рівні застосунку, тобто в масиві `providersPerApp`". Але при цьому, в даному сервісі ви хочете бачити інстанси класу `Request` та `Response`:

```ts
import { Injectable } from '@ts-stack/di';
import { Logger, Request, Response, ControllerErrorHandler } from '@ditsmod/core';

@Injectable()
export class ErrorHandlerService implements ControllerErrorHandler {
  constructor(
    private req: Request,
    private res: Response,
    private log: Logger
  ) {}

  handleError(err: Error) {
    // Тут код для обробки помилки
  }
}
```

Ви запускаєте застосунок, і коли справа доходить до роботи цього сервісу, DI кидає помилку, про те, що він не може знайти провайдера для `Request` та `Response`. Але чому? Може їх треба самостійно оголосити на рівні HTTP-запиту, тобто додати їх у масив `providersPerReq`? Ви так і робите, але DI все-одно кидає помилку...

Причина криїться у невірно оголошеному рівні для `ErrorHandlerService`. Оскільки ви оголосили цей сервіс на рівні застосунку, ним буде опікуватись інжектор на рівні застосунку. А це означає, що усі сервіси, що ви запитуєте в конструкторі цього сервісу, буде створювати саме інжектор на рівні застосунку.

Разом з тим, `Request` та `Response` в Ditsmod оголошені на рівні запиту, і саме тому їх не бачить вищий в ієрархії інжектор.

Вирішити цю проблему можна двома способами:

1. або ви видалите `Request` та `Response` з конструктора даного сервіса;
2. або ви оголосите `ErrorHandlerService` на рівні запиту. Щоправда, в такому разі видимість `ErrorHandlerService` буде обмежуватись лише тим модулем, де ви оголосили цей провайдер. Як правильно оголосити обробника помилок для контролера, прогляньте [репозиторій ditsmod/seed][14].

### Поточний інжектор

Швидше за все, безпосередньо сам інжектор вам навряд чи знадобиться, але ви його можете отримати у конструкторі як і будь-який інший інстанс провайдера:

```ts
import { Injectable, Injector } from '@ts-stack/di';
import { FirstService } from './first.service';

@Injectable()
export class SecondService {
  constructor(private injector: Injector) {}

  someMethod() {
    const firstService = this.injector.get(FirstService);
  }
}
```

Майте на увазі, що ви таким чином отримуєте інжектор, що створив інстанс цього провайдера.

### Токени DI

Інжектор, в якості ключів для пошуку провайдерів, використовує так звані токени. Тип токена може бути або класом, або об'єктом, або рядком (тобто `string`), або JavaScript-символом (тобто `symbol`). У якості токена не можуть бути інтерфейси чи типи, що оголошені з ключовим словом `type`, оскільки після їх компіляції із TypeScript у JavaScript, від них нічого не залишиться у JavaScript-файлах.

Разом із тим, у конструкторі, в якості токена, найпростіше указати клас певного сервісу:

```ts
import { Injectable } from '@ts-stack/di';

import { SecondService } from './second.service';

@Injectable()
export class FirstService {
  constructor(private secondService: SecondService) {}

  methodOne() {
    this.secondService.doSomeThing();
  }
}
```

DI проглядатиме конструктор, знайде `SecondService`, після чого у відповідних інжекторах шукатиме провайдера по цьому класу. Тут варто звернути увагу, що DI у якості токена використає саме клас, а не назву класу.

Для токенів інших типів, в конструкторі необхідно використовувати декоратор `Inject` перед модифікаторами доступу. Накриклад, у якості токена ви можете використовувати рядок `tokenForLocal`:

```ts
import { Injectable, Inject } from '@ts-stack/di';

@Injectable()
export class SomeService {
  constructor(@Inject('tokenForLocal') private local: string) {}

  methodOne() {
    this.local;
  }
}
```

В такому разі, щоб DI зміг знайти відповідний провайдер, вам необхідно оголошувати цей провайдер із таким же токеном:

```ts
import { Module } from '@ditsmod/core';

@Module({
  providersPerMod: [
    { provide: 'tokenForLocal', useValue: 'uk' }
  ]
})
export class SomeModule {}
```

Зверніть увагу, що при оголошенні провайдера, використовується властивість `useValue`. В такому разі DI не буде намагатись створити інстанс класу, а видасть без змін те значення, що ви передали.

**Зауваження** У якості токена для DI рекомендується використовувати саме класи, де тільки це можливо. Досить рідко може знадобитись використовувати токени інших типів.

### InjectionToken

Окрім можливості використання токенів, що мають різні типи даних, DI має спеціальний клас, рекомендований для створення токенів - `InjectionToken`. Оскільки він має параметр для типу (дженерік), ви зможете прочитати тип даних, що буде повертати DI, при запиті конкретного токена:

```ts
import { InjectionToken } from '@ts-stack/di';

export const localToken = new InjectionToken<string>('tokenForLocal');
```

Користуватись ним можна точно так само, як і усіма іншими токенами, що не є класами. В конструкторі:

```ts
import { Injectable, Inject } from '@ts-stack/di';

import { localToken } from './tokens';

@Injectable()
export class SomeService {
  constructor(@Inject(localToken) private local: string) {}

  methodOne() {
    this.local;
  }
}
```

При оголошенні рівня провайдера:

```ts
import { Module } from '@ditsmod/core';

import { localToken } from './tokens';

@Module({
  providersPerMod: [
    { provide: localToken, useValue: 'uk' }
  ]
})
export class SomeModule {}
```

Зверніть увагу, що `InjectionToken` імпортується з `@ts-stack/di`, а не з `@ditsmod/core`.

## Колізії провайдерів

Уявіть, що у вас є `Module1`, куди ви імпортували `Module2` та `Module3`. Ви зробили такий імпорт, бо вам потрібні відповідно `Service2` та `Service3` із цих модулів. Ви проглядаєте результат роботи даних сервісів, але по якійсь причині `Service3` працює не так як очікується. Ви починаєте дебажити і виявляється, що `Service3` експортують обидва модулі: `Module2` та `Module3`. Ви очікували, що `Service3` експортуватиметься лише із `Module3`, але насправді спрацювала та версія, що експортується із `Module2`.

Щоб цього не сталось, якщо ви імпортуєте два або більше модулі, в яких експортуються провайдери з однаковим токеном, Ditsmod кидатиме приблизно таку помилку:

> Error: Exporting providers in Module1 was failed: Collision was found for: Service3. You should manually add this provider to Module1.

Конкретно у цій ситуації:

1. і `Module2` підмінює, а потім експортує провайдер з токеном `Service3`;
2. і `Module3` підмінює, а потім експортує провайдер з токеном `Service3`.

І оскільки обидва цих модулі імпортуються у `Module1`, якраз тому і виникає "колізія провайдерів", розробник може не знати яка із цих підмін буде працювати в `Module1`.

Даної помилки можна уникнути, якщо продублювати оголошення провайдера на потрібному рівні із цим же токеном:

```ts
import { Module2 } from './module2';
import { Module3, ServiceFromModule3 } from './module3';

@Module({
  imports: [Module2, Module3]
  providersPerReq: [{ provide: Service3, useClass: ServiceFromModule3 }]
})
export class Module1 {}
```

Таким чином ви явно вирішуєте колізію із `Service3`.

## Домовленості по стилю коду

Тут наводиться рекомендований формат у вигляді пари "назва файлу" - "ім'я класу":

- `hello-world.controller` - `HelloWorldController`;
- `hello-world.service` - `HelloWorldService`;
- `hello-world.module` - `HelloWorldModule`;
- `auth.guard` - `AuthGuard`;

Кореневий модуль рекомендується називати `AppModule`.

При імпорті рекомендується не змішувати імпорт з локальних файлів та імпорт з `node_modules`. Вгорі йдуть імпорти з `node_modules`, через один рядок йдуть локальні імпорти:

```ts
import { Injectable } from '@ts-stack/di';
import { CanActivate, Status } from '@ditsmod/core';

import { AuthService } from './auth.service';
import { Permission } from './permission';
```

Розширення повинні мати закінчення `_EXTENSIONS`, наприклад `MY_EXTENSIONS`.

## API reference

Даний розділ з'явиться пізніше.

[2]: https://github.com/ditsmod/seed
[4]: ./examples.md
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[9]: https://github.com/angular/angular
[10]: https://jestjs.io/en/
[11]: https://github.com/ts-stack/di
[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
[14]: https://github.com/ditsmod/seed/blob/901f247/src/app/app.module.ts#L18

[100]: #оголошення-рівня-провайдерів-та-підміна-провайдерів

[100]: #оголошення-рівня-провайдерів-та-підміна-провайдерів
[102]: #кореневий-модуль-ditsmod
[103]: #контролер
[104]: #сервіс
[105]: #dependency-injection
[106]: #api-reference
[106]: #api-reference
[107]: #експорт-провайдерів-зі-звичайного-модуля
[107]: #експорт-провайдерів-зі-звичайного-модуля
[108]: #експорт-провайдерів-із-кореневого-модуля
[109]: #імпорт-модуля
[110]: #реекспорт-модуля
[111]: #оголошення-контролера
[112]: #префікси-маршрутів
[113]: #guards
[114]: #параметри-для-guards
[115]: #автоматичний-парсинг-тіла-http-запиту
[116]: #підміна-by-default-провайдерів-ditsmod
[117]: #різниця-між-областю-видимості-провайдерів-та-їх-рівнями-оголошення
[118]: #інжектори-di
[119]: #токени-di
[120]: #injectiontoken
[121]: #колізії-провайдерів
[121]: #колізії-провайдерів
[122]: #домовленості-по-стилю-коду
[123]: #вхідний-файл-для-nodejs
[127]: #пріоритетність-провайдерів
[142]: #поточний-інжектор
[150]: #модуль-ditsmod
